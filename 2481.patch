From 31798e4fe28ee5d31ecb6e822015cb3651ae232f Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Tue, 18 Dec 2018 14:10:41 -0600
Subject: [PATCH 1/5] survive unsufficient privs for devpts, and use
 /dev/console with minimal /dev

---
 .../runtime/engines/singularity/container.go  | 73 +++++++++++++------
 1 file changed, 50 insertions(+), 23 deletions(-)

diff --git a/internal/pkg/runtime/engines/singularity/container.go b/internal/pkg/runtime/engines/singularity/container.go
index cbe79cc70..3300d8905 100644
--- a/internal/pkg/runtime/engines/singularity/container.go
+++ b/internal/pkg/runtime/engines/singularity/container.go
@@ -5,6 +5,11 @@
 
 package singularity
 
+/*
+char *ttyname(int fd);
+*/
+import "C"
+
 import (
 	"fmt"
 	"io/ioutil"
@@ -399,9 +404,13 @@ func (c *container) mount(point *mount.Point) error {
 			if flags&syscall.MS_REMOUNT != 0 {
 				return fmt.Errorf("can't remount %s: %s", point.Destination, err)
 			}
-			// mount error for filesystems is considered fatal
 			if point.Type != "" {
-				return fmt.Errorf("can't mount %s filesystem to %s: %s", point.Type, point.Destination, err)
+				if point.Source == "devpts" {
+					sylog.Verbosef("Couldn't mount devpts filesystem, continuing with PTY allocation functionality disabled")
+				} else {
+					// mount error for other filesystems is considered fatal
+					return fmt.Errorf("can't mount %s filesystem to %s: %s", point.Type, point.Destination, err)
+				}
 			}
 			sylog.Verbosef("can't mount %s: %s", point.Source, err)
 			return nil
@@ -885,47 +894,51 @@ func (c *container) addKernelMount(system *mount.System) error {
 	return nil
 }
 
-func (c *container) addSessionDev(devpath string, system *mount.System) error {
-	fi, err := os.Lstat(devpath)
+func (c *container) addSessionDevAt(srcpath string, atpath string, system *mount.System) error {
+	fi, err := os.Lstat(srcpath)
 	if err != nil {
 		return err
 	}
 
 	switch mode := fi.Mode(); {
 	case mode&os.ModeSymlink != 0:
-		target, err := os.Readlink(devpath)
+		target, err := os.Readlink(srcpath)
 		if err != nil {
 			return err
 		}
-		if err := c.session.AddSymlink(devpath, target); err != nil {
-			return fmt.Errorf("failed to create symlink %s", devpath)
+		if err := c.session.AddSymlink(atpath, target); err != nil {
+			return fmt.Errorf("failed to create symlink %s", atpath)
 		}
 
-		dst, _ := c.session.GetPath(devpath)
+		dst, _ := c.session.GetPath(atpath)
 
-		sylog.Debugf("Adding symlink device %s at %s", devpath, dst)
+		sylog.Debugf("Adding symlink device %s to %s at %s", srcpath, target, dst)
 
 		return nil
 	case mode.IsDir():
-		if err := c.session.AddDir(devpath); err != nil {
-			return fmt.Errorf("failed to add %s session dir: %s", devpath, err)
+		if err := c.session.AddDir(atpath); err != nil {
+			return fmt.Errorf("failed to add %s session dir: %s", atpath, err)
 		}
 	default:
-		if err := c.session.AddFile(devpath, nil); err != nil {
-			return fmt.Errorf("failed to add %s session file: %s", devpath, err)
+		if err := c.session.AddFile(atpath, nil); err != nil {
+			return fmt.Errorf("failed to add %s session file: %s", atpath, err)
 		}
 	}
 
-	dst, _ := c.session.GetPath(devpath)
+	dst, _ := c.session.GetPath(atpath)
 
-	sylog.Debugf("Mounting device %s at %s", devpath, dst)
+	sylog.Debugf("Mounting device %s at %s", srcpath, dst)
 
-	if err := system.Points.AddBind(mount.DevTag, devpath, dst, syscall.MS_BIND); err != nil {
-		return fmt.Errorf("failed to add %s mount: %s", devpath, err)
+	if err := system.Points.AddBind(mount.DevTag, srcpath, dst, syscall.MS_BIND); err != nil {
+		return fmt.Errorf("failed to add %s mount: %s", srcpath, err)
 	}
 	return nil
 }
 
+func (c *container) addSessionDev(devpath string, system *mount.System) error {
+	return c.addSessionDevAt(devpath, devpath, system)
+}
+
 func (c *container) addSessionDevMount(system *mount.System) error {
 	if c.devSourcePath == "" {
 		c.devSourcePath, _ = c.session.GetPath("/dev")
@@ -976,7 +989,7 @@ func (c *container) addDevMount(system *mount.System) error {
 
 			sylog.Debugf("Creating temporary staged /dev/pts")
 			if err := c.session.AddDir("/dev/pts"); err != nil {
-				return fmt.Errorf("failed to /dev/pts session directory: %s", err)
+				return fmt.Errorf("failed to add /dev/pts session directory: %s", err)
 			}
 
 			options := "mode=0620,newinstance,ptmxmode=0666"
@@ -994,14 +1007,28 @@ func (c *container) addDevMount(system *mount.System) error {
 			devptsPath, _ := c.session.GetPath("/dev/pts")
 			err = system.Points.AddFS(mount.DevTag, devptsPath, "devpts", syscall.MS_NOSUID|syscall.MS_NOEXEC, options)
 			if err != nil {
-				sylog.Verbosef("Couldn't mount devpts filesystem, continuing with PTY functionality disabled")
-			} else {
-				if err := c.addSessionDev("/dev/tty", system); err != nil {
+				return fmt.Errorf("failed to add devpts filesystem: %s", err)
+			}
+			// add additional PTY allocation symlink
+			if err := c.session.AddSymlink("/dev/ptmx", "/dev/pts/ptmx"); err != nil {
+				return fmt.Errorf("failed to create /dev/ptmx symlink: %s", err)
+			}
+
+		}
+		// add /dev/console mount pointing to original tty if there is one
+		for fd := 0; fd <= 2; fd++ {
+			if tty := C.GoString(C.ttyname(C.int(fd))); tty != "" {
+				// found a ttyname on stdin, stdout, or stderr
+				// bind mount it at /dev/console
+				sylog.Debugf("Fd %d is tty %s; binding to /dev/console", fd, tty)
+				if err := c.addSessionDevAt(tty, "/dev/console", system); err != nil {
 					return err
 				}
-				if err := c.session.AddSymlink("/dev/ptmx", "/dev/pts/ptmx"); err != nil {
-					return fmt.Errorf("failed to create /dev/ptmx symlink: %s", err)
+				// and also add a /dev/tty
+				if err := c.addSessionDev("/dev/tty", system); err != nil {
+					return err
 				}
+				break
 			}
 		}
 		if err := c.addSessionDev("/dev/null", system); err != nil {

From 75103899ffdacf221fb070920395a4ae42e1e357 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 19 Dec 2018 17:46:45 -0600
Subject: [PATCH 2/5] use less functional readlink of /proc/self/fd/N instead
 of C ttyname

---
 .../runtime/engines/singularity/container.go  | 30 ++++++++++++-------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/internal/pkg/runtime/engines/singularity/container.go b/internal/pkg/runtime/engines/singularity/container.go
index 3300d8905..9523f4956 100644
--- a/internal/pkg/runtime/engines/singularity/container.go
+++ b/internal/pkg/runtime/engines/singularity/container.go
@@ -5,11 +5,6 @@
 
 package singularity
 
-/*
-char *ttyname(int fd);
-*/
-import "C"
-
 import (
 	"fmt"
 	"io/ioutil"
@@ -36,6 +31,7 @@ import (
 	"github.com/sylabs/singularity/internal/pkg/util/fs/proc"
 	"github.com/sylabs/singularity/internal/pkg/util/user"
 	"github.com/sylabs/singularity/pkg/util/loop"
+	"golang.org/x/crypto/ssh/terminal"
 )
 
 type container struct {
@@ -1017,11 +1013,25 @@ func (c *container) addDevMount(system *mount.System) error {
 		}
 		// add /dev/console mount pointing to original tty if there is one
 		for fd := 0; fd <= 2; fd++ {
-			if tty := C.GoString(C.ttyname(C.int(fd))); tty != "" {
-				// found a ttyname on stdin, stdout, or stderr
-				// bind mount it at /dev/console
-				sylog.Debugf("Fd %d is tty %s; binding to /dev/console", fd, tty)
-				if err := c.addSessionDevAt(tty, "/dev/console", system); err != nil {
+			if terminal.IsTerminal(fd) {
+				// Found a tty on stdin, stdout, or stderr.
+				// Bind mount it at /dev/console.
+				// readlink from /proc/self/fd/N isn't as
+				//  reliable as ttyname() (e.g. it doesn't work
+				//  in docker), but no golang ttyname() so
+				//  use it for now.
+				procfd := fmt.Sprintf("/proc/self/fd/%d", fd)
+				ttylink, err := os.Readlink(procfd)
+				if err != nil {
+					return err
+				}
+
+				if _, err := os.Stat(ttylink); err != nil {
+					sylog.Debugf("Fd %d is tty but %s doesn't exist, skipping", fd, ttylink)
+					continue
+				}
+				sylog.Debugf("Fd %d is tty %s, linking to /dev/console", fd, ttylink)
+				if err := c.addSessionDevAt(ttylink, "/dev/console", system); err != nil {
 					return err
 				}
 				// and also add a /dev/tty

From 54faf6ac8714aa39d5affaf55865043ed182f632 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 19 Dec 2018 20:31:54 -0600
Subject: [PATCH 3/5] if /proc/self/fd/N link is bad, try /dev/console

---
 .../runtime/engines/singularity/container.go  | 24 +++++++++++++++----
 1 file changed, 20 insertions(+), 4 deletions(-)

diff --git a/internal/pkg/runtime/engines/singularity/container.go b/internal/pkg/runtime/engines/singularity/container.go
index 9523f4956..dc7226288 100644
--- a/internal/pkg/runtime/engines/singularity/container.go
+++ b/internal/pkg/runtime/engines/singularity/container.go
@@ -1019,7 +1019,8 @@ func (c *container) addDevMount(system *mount.System) error {
 				// readlink from /proc/self/fd/N isn't as
 				//  reliable as ttyname() (e.g. it doesn't work
 				//  in docker), but no golang ttyname() so
-				//  use it for now.
+				//  use it for now and also check the device
+				//  that docker uses, /dev/console.
 				procfd := fmt.Sprintf("/proc/self/fd/%d", fd)
 				ttylink, err := os.Readlink(procfd)
 				if err != nil {
@@ -1027,10 +1028,25 @@ func (c *container) addDevMount(system *mount.System) error {
 				}
 
 				if _, err := os.Stat(ttylink); err != nil {
-					sylog.Debugf("Fd %d is tty but %s doesn't exist, skipping", fd, ttylink)
-					continue
+					// Check if in a system like docker
+					//  using /dev/console already
+					consinfo := new(syscall.Stat_t)
+					conserr := syscall.Stat("/dev/console", consinfo)
+					fdinfo := new(syscall.Stat_t)
+					fderr := syscall.Fstat(fd, fdinfo)
+					if conserr == nil &&
+						fderr == nil &&
+						consinfo.Ino == fdinfo.Ino &&
+						consinfo.Rdev == fdinfo.Rdev {
+						sylog.Debugf("Fd %d is tty pointing to nonexistent %s but /dev/console is good", fd, ttylink)
+						ttylink = "/dev/console"
+
+					} else {
+						sylog.Debugf("Fd %d is tty but %s doesn't exist, skipping", fd, ttylink)
+						continue
+					}
 				}
-				sylog.Debugf("Fd %d is tty %s, linking to /dev/console", fd, ttylink)
+				sylog.Debugf("Fd %d is tty %s, binding to /dev/console", fd, ttylink)
 				if err := c.addSessionDevAt(ttylink, "/dev/console", system); err != nil {
 					return err
 				}

From 78f5cbc8ec6a26969f9f41581fcfe5acdaefc0ea Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Sat, 22 Dec 2018 21:08:19 -0600
Subject: [PATCH 4/5] reduce in-loop indentation

---
 .../runtime/engines/singularity/container.go  | 79 ++++++++++---------
 1 file changed, 40 insertions(+), 39 deletions(-)

diff --git a/internal/pkg/runtime/engines/singularity/container.go b/internal/pkg/runtime/engines/singularity/container.go
index dc7226288..4fff31dab 100644
--- a/internal/pkg/runtime/engines/singularity/container.go
+++ b/internal/pkg/runtime/engines/singularity/container.go
@@ -1013,49 +1013,50 @@ func (c *container) addDevMount(system *mount.System) error {
 		}
 		// add /dev/console mount pointing to original tty if there is one
 		for fd := 0; fd <= 2; fd++ {
-			if terminal.IsTerminal(fd) {
-				// Found a tty on stdin, stdout, or stderr.
-				// Bind mount it at /dev/console.
-				// readlink from /proc/self/fd/N isn't as
-				//  reliable as ttyname() (e.g. it doesn't work
-				//  in docker), but no golang ttyname() so
-				//  use it for now and also check the device
-				//  that docker uses, /dev/console.
-				procfd := fmt.Sprintf("/proc/self/fd/%d", fd)
-				ttylink, err := os.Readlink(procfd)
-				if err != nil {
-					return err
-				}
+			if !terminal.IsTerminal(fd) {
+				continue
+			}
+			// Found a tty on stdin, stdout, or stderr.
+			// Bind mount it at /dev/console.
+			// readlink() from /proc/self/fd/N isn't as reliable as
+			//  ttyname() (e.g. it doesn't work in docker), but
+			//  there is no golang ttyname() so use this for now
+			//  and also check the device that docker uses,
+			//  /dev/console.
+			procfd := fmt.Sprintf("/proc/self/fd/%d", fd)
+			ttylink, err := os.Readlink(procfd)
+			if err != nil {
+				return err
+			}
 
-				if _, err := os.Stat(ttylink); err != nil {
-					// Check if in a system like docker
-					//  using /dev/console already
-					consinfo := new(syscall.Stat_t)
-					conserr := syscall.Stat("/dev/console", consinfo)
-					fdinfo := new(syscall.Stat_t)
-					fderr := syscall.Fstat(fd, fdinfo)
-					if conserr == nil &&
-						fderr == nil &&
-						consinfo.Ino == fdinfo.Ino &&
-						consinfo.Rdev == fdinfo.Rdev {
-						sylog.Debugf("Fd %d is tty pointing to nonexistent %s but /dev/console is good", fd, ttylink)
-						ttylink = "/dev/console"
+			if _, err := os.Stat(ttylink); err != nil {
+				// Check if in a system like docker
+				//  using /dev/console already
+				consinfo := new(syscall.Stat_t)
+				conserr := syscall.Stat("/dev/console", consinfo)
+				fdinfo := new(syscall.Stat_t)
+				fderr := syscall.Fstat(fd, fdinfo)
+				if conserr == nil &&
+					fderr == nil &&
+					consinfo.Ino == fdinfo.Ino &&
+					consinfo.Rdev == fdinfo.Rdev {
+					sylog.Debugf("Fd %d is tty pointing to nonexistent %s but /dev/console is good", fd, ttylink)
+					ttylink = "/dev/console"
 
-					} else {
-						sylog.Debugf("Fd %d is tty but %s doesn't exist, skipping", fd, ttylink)
-						continue
-					}
-				}
-				sylog.Debugf("Fd %d is tty %s, binding to /dev/console", fd, ttylink)
-				if err := c.addSessionDevAt(ttylink, "/dev/console", system); err != nil {
-					return err
-				}
-				// and also add a /dev/tty
-				if err := c.addSessionDev("/dev/tty", system); err != nil {
-					return err
+				} else {
+					sylog.Debugf("Fd %d is tty but %s doesn't exist, skipping", fd, ttylink)
+					continue
 				}
-				break
 			}
+			sylog.Debugf("Fd %d is tty %s, binding to /dev/console", fd, ttylink)
+			if err := c.addSessionDevAt(ttylink, "/dev/console", system); err != nil {
+				return err
+			}
+			// and also add a /dev/tty
+			if err := c.addSessionDev("/dev/tty", system); err != nil {
+				return err
+			}
+			break
 		}
 		if err := c.addSessionDev("/dev/null", system); err != nil {
 			return err

From 945df308251abf9470e6949fcc33f0634e3bb76b Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Sat, 22 Dec 2018 21:09:10 -0600
Subject: [PATCH 5/5] open /dev/console with minimal /dev

---
 .../runtime/engines/singularity/process.go    | 33 +++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/internal/pkg/runtime/engines/singularity/process.go b/internal/pkg/runtime/engines/singularity/process.go
index bc200101f..f7eb2c91a 100644
--- a/internal/pkg/runtime/engines/singularity/process.go
+++ b/internal/pkg/runtime/engines/singularity/process.go
@@ -25,6 +25,7 @@ import (
 	specs "github.com/opencontainers/runtime-spec/specs-go"
 	"github.com/sylabs/singularity/internal/pkg/instance"
 	"github.com/sylabs/singularity/internal/pkg/sylog"
+	"golang.org/x/crypto/ssh/terminal"
 )
 
 func (engine *EngineOperations) checkExec() error {
@@ -127,6 +128,38 @@ func (engine *EngineOperations) StartProcess(masterConn net.Conn) error {
 		return err
 	}
 
+	if engine.EngineConfig.File.MountDev == "minimal" || engine.EngineConfig.GetContain() {
+		// If on a terminal, reopen /dev/console so /proc/self/fd/[0-2
+		//   will point to /dev/console.  This is needed so that tty and
+		//   ttyname() on el6 will return the correct answer.  Newer
+		//   ttyname() functions might work because they will search
+		//   /dev if the value of /proc/self/fd/X doesn't exist, but
+		//   they won't work if another /dev/pts/X is allocated in its
+		//   place.  Also, programs that don't use ttyname() and instead
+		//   directly do readlink() on /proc/self/fd/X need this.
+		for fd := 0; fd <= 2; fd++ {
+			if !terminal.IsTerminal(fd) {
+				continue
+			}
+			consfile, err := os.OpenFile("/dev/console", os.O_RDWR, 0600)
+			if err != nil {
+				sylog.Debugf("Could not open minimal /dev/console, skipping replacing tty descriptors")
+				break
+			}
+			sylog.Debugf("Replacing tty descriptors with /dev/console")
+			consfd := int(consfile.Fd())
+			for ; fd <= 2; fd++ {
+				if !terminal.IsTerminal(fd) {
+					continue
+				}
+				syscall.Close(fd)
+				syscall.Dup2(consfd, fd)
+			}
+			consfile.Close()
+			break
+		}
+	}
+
 	args := engine.EngineConfig.OciConfig.Process.Args
 	env := engine.EngineConfig.OciConfig.Process.Env
 
